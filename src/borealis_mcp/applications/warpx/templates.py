"""WarpX application templates for Borealis MCP."""

from __future__ import annotations

from typing import Any, Dict, List, Optional

# SystemConfig is only used for typing and for access to
# system_config.display_name and system_config.default_filesystems.
# Keep import optional so this module can be imported in minimal environments.
try:
    from borealis_mcp.config.system import SystemConfig
except ModuleNotFoundError:  # pragma: no cover
    SystemConfig = Any  # type: ignore[assignment,misc]


class WarpXTemplates:
    """PBS submit script templates for WarpX Python PICMI runs."""

    @staticmethod
    def generate_submit_script(
        *,
        system_config: SystemConfig,
        job_name: str,
        account: str,
        queue: str,
        walltime: str,
        filesystems: Optional[str],
        run_dir: str,
        modules: List[str],
        env_vars: Dict[str, Any],
        warpx_prefix: Optional[str],
        profile_source: Optional[str],
        venv_activate: Optional[str],
        mpi_command: str,
        mpi_env_flag: str,
        mpi_flags: List[str],
        num_nodes: int,
        ranks_per_node: int,
        threads_per_rank: int,
        driver_basename: str,
        driver_args: str,
        cpu_bind: Optional[str],
        gpu_bind: Optional[str],
    ) -> str:
        # Prefer explicit filesystems from parameter, fall back to system default.
        if filesystems:
            fs = filesystems
        else:
            fs = ":".join(system_config.default_filesystems)

        # Module and env sections
        module_section = ""
        if modules:
            module_cmds = "module use /soft/modulefiles\n" + "\n".join(
                [f"module load {m}" for m in modules]
            )
            module_section = f"""# --- Modules ---------------------------------------------------------------\n{module_cmds}\n"""
        else:
            module_section = "# --- Modules ---------------------------------------------------------------\n# (none)\n"

        env_lines = [f'export {k}="{v}"' for k, v in (env_vars or {}).items()]
        env_section = "\n".join(env_lines) if env_lines else "# (none)"

        # Source profile and venv
        setup_lines: List[str] = []
        if warpx_prefix:
            setup_lines.append(f"export WARPX_PREFIX=\"{warpx_prefix}\"")

        if profile_source:
            setup_lines.append(f"source {profile_source}")

        # If no explicit module list was provided, users may rely on profile to set modules.
        # If both are present, module loads happen first, then profile.

        if venv_activate:
            setup_lines.append(f"source {venv_activate}")

        setup_section = "\n".join(setup_lines) if setup_lines else "# (none)"

        # MPI binding flags (strings already contain leading flag names)
        bind_flags: List[str] = []
        if cpu_bind:
            bind_flags.append(cpu_bind)
        if gpu_bind:
            bind_flags.append(gpu_bind)
        bind_str = " ".join(bind_flags)

        extra_flags = " ".join(mpi_flags or [])

        # Quote driver args as a single string; caller is responsible for providing
        # a correct bash fragment. (Later we can change to list[str] for safety.)
        driver_cmd = f"./{driver_basename} {driver_args}".strip()

        # Logging to run_dir (Variant A)
        return f'''#!/bin/bash -l
#PBS -A {account}
#PBS -N {job_name}
#PBS -l select={num_nodes}
#PBS -l walltime={walltime}
#PBS -l filesystems={fs}
#PBS -l place=scatter
#PBS -q {queue}
#PBS -k doe

# =============================================================================
# WarpX (Python PICMI driver) - PBS Submit Script
# =============================================================================
# System: {system_config.display_name}
# Run directory: {run_dir}
# Total ranks: {num_nodes * ranks_per_node} ({num_nodes} nodes x {ranks_per_node} ranks/node)
# Threads per rank: {threads_per_rank}
# Generated by Borealis MCP
# =============================================================================

set -euo pipefail

RUN_DIR="{run_dir}"
cd "${{RUN_DIR}}"

# Redirect stdout/stderr to run directory
exec > "${{RUN_DIR}}/warpx_stdout.log" 2> "${{RUN_DIR}}/warpx_stderr.log"

echo "Jobid: ${{PBS_JOBID:-}}"
echo "Running on host $(hostname)"
echo "Working directory: ${{PBS_O_WORKDIR:-$RUN_DIR}}"
echo "Run directory is $RUN_DIR"
echo "Nodes: $(cat ${{PBS_NODEFILE:-/dev/null}} | sort -u | wc -l)"
echo "PBS_NODEFILE: ${{PBS_NODEFILE:-}}"
echo ""

{module_section}

# --- Environment Variables ---------------------------------------------------
{env_section}

# --- WarpX Environment Setup -------------------------------------------------
# warpx_prefix: {warpx_prefix or '(unset)'}
# profile_source: {profile_source or '(unset)'}
# venv_activate: {venv_activate or '(unset)'}
{setup_section}

# --- MPI Configuration --------------------------------------------------------
NNODES={num_nodes}
NRANKS_PER_NODE={ranks_per_node}
NTOTRANKS=$(( NNODES * NRANKS_PER_NODE ))
NTHREADS={threads_per_rank}

echo "NNODES=$NNODES NRANKS_PER_NODE=$NRANKS_PER_NODE NTOTRANKS=$NTOTRANKS NTHREADS=$NTHREADS"

# --- Run ---------------------------------------------------------------------
# Driver: {driver_basename}
# Args: {driver_args}

echo "Starting WarpX driver at $(date)"

echo "{mpi_command} --np $NTOTRANKS -ppn $NRANKS_PER_NODE {bind_str} {mpi_env_flag} {extra_flags} {driver_cmd} > log.out"

{mpi_command} --np $NTOTRANKS -ppn $NRANKS_PER_NODE {bind_str} {mpi_env_flag} {extra_flags} {driver_cmd} > log.out

EXIT_CODE=$?

echo "WarpX driver finished at $(date) with exit code $EXIT_CODE"
exit $EXIT_CODE
'''
