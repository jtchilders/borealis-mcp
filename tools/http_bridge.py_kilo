#!/usr/bin/env python3
"""
HTTP Bridge for Borealis MCP

Translates between STDIO (MCP client) and HTTP (remote MCP server).
This allows MCP clients to connect to Borealis running on Aurora via SSH tunnel.

Usage:
    python http_bridge.py http://localhost:9000/mcp

Setup:
    1. Establish SSH tunnel: ssh -L 9000:localhost:9000 user@aurora.alcf.anl.gov
    2. On Aurora, start Borealis in HTTP mode: python -m borealis_mcp.server --transport http
    3. Configure MCP client to use this bridge
"""

import argparse
import json
import sys
from typing import Optional

try:
    import requests
except ImportError:
    print(
        "Error: requests library not installed. Run: pip install requests",
        file=sys.stderr,
    )
    sys.exit(1)


class HTTPBridge:
    """Bridge between STDIO and HTTP for MCP communication."""

    def __init__(self, server_url: str):
        """
        Initialize HTTP bridge.

        Args:
            server_url: URL of the HTTP MCP server (e.g., http://localhost:9000/mcp)
        """
        self.server_url = server_url.rstrip("/")
        self.session = requests.Session()
        # FastMCP HTTP transport uses a session id and requires X-Session-ID on
        # subsequent requests after initialize.
        self.session_id: Optional[str] = "1"

        # Ensure server is reachable
        self._check_server()

        # Pre-seed a session id for servers that require X-Session-ID on all
        # requests. Many FastMCP deployments key sessions by initialize request id;
        # the bridge will update this if the server provides X-Session-ID.
        self.session_id = "1"

    def _check_server(self) -> None:
        """Check if server is reachable."""
        try:
            response = self.session.get(f"{self.server_url}/health", timeout=5)
            response.raise_for_status()
            print(f"Connected to MCP server at {self.server_url}", file=sys.stderr)
        except requests.exceptions.RequestException as e:
            print(
                f"Warning: Health check failed for {self.server_url}",
                file=sys.stderr,
            )
            print(f"Details: {e}", file=sys.stderr)
            print("Continuing anyway - server may not support /health endpoint", file=sys.stderr)

    def send_request(self, request: dict) -> dict:
        """
        Send JSON-RPC request to HTTP server.

        Args:
            request: JSON-RPC request object

        Returns:
            JSON-RPC response object
        """
        try:
            # FastMCP HTTP transport requires clients to accept both JSON and SSE.
            headers = {
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream",
            }

            # FastMCP uses a session id; in practice this is the value of the
            # initialization request id. Use that as the session id unless the
            # server later provides X-Session-ID.
            if self.session_id:
                # Some FastMCP deployments expect lowercase header names.
                headers["X-Session-ID"] = self.session_id
                headers["x-session-id"] = self.session_id

            # Borealis FastMCP HTTP transport serves the MCP endpoint at
            #   http://HOST:PORT/mcp
            # and accepts JSON-RPC POSTs directly at that path.
            #
            # Older bridge versions attempted POST to /messages which is not
            # served by this server.
            response = self.session.post(
                f"{self.server_url}",
                json=request,
                headers=headers,
                timeout=30,
            )
            response.raise_for_status()

            # Extract session ID from response if provided. If the server does not
            # provide one, keep the existing session id (set from initialize id).
            if "X-Session-ID" in response.headers:
                self.session_id = response.headers["X-Session-ID"]
            elif self.session_id is None and request.get("method") == "initialize":
                # Fallback for servers that key sessions by initialize request id.
                self.session_id = str(request.get("id"))

            # FastMCP may return server responses as:
            # - application/json
            # - text/event-stream (SSE) with one or more "data: {json}" lines
            content_type = (response.headers.get("Content-Type") or "").lower()
            text = response.text

            if "text/event-stream" in content_type or text.lstrip().startswith("event:"):
                # Parse first JSON object from an SSE message
                for line in text.splitlines():
                    line = line.strip()
                    if line.startswith("data:"):
                        data = line[len("data:") :].strip()
                        if data:
                            return json.loads(data)
                return {
                    "jsonrpc": "2.0",
                    "id": request.get("id"),
                    "error": {
                        "code": -32000,
                        "message": "HTTP server returned SSE without JSON data",
                    },
                }

            return response.json()

        except requests.exceptions.RequestException as e:
            # Include server response body when available (very helpful for 400s).
            body = ""
            resp = getattr(e, "response", None)
            if resp is not None:
                try:
                    body = resp.text
                except Exception:
                    body = ""

            msg = f"HTTP request failed: {str(e)}"
            if body:
                msg = f"{msg} | body={body}"

            return {
                "jsonrpc": "2.0",
                "id": request.get("id"),
                "error": {"code": -32000, "message": msg},
            }

    def run(self) -> None:
        """
        Main loop: read from stdin, send to HTTP server, write response to stdout.
        """
        print("HTTP Bridge started", file=sys.stderr)
        print(f"Server URL: {self.server_url}", file=sys.stderr)
        print("Waiting for MCP messages on stdin...", file=sys.stderr)

        for line in sys.stdin:
            line = line.strip()
            if not line:
                continue

            try:
                # Parse JSON-RPC request from stdin
                request = json.loads(line)

                # Send to HTTP server
                response = self.send_request(request)

                # Write response to stdout
                print(json.dumps(response), flush=True)

            except json.JSONDecodeError as e:
                error_response = {
                    "jsonrpc": "2.0",
                    "id": None,
                    "error": {"code": -32700, "message": f"Parse error: {str(e)}"},
                }
                print(json.dumps(error_response), flush=True)

            except Exception as e:
                error_response = {
                    "jsonrpc": "2.0",
                    "id": None,
                    "error": {"code": -32603, "message": f"Internal error: {str(e)}"},
                }
                print(json.dumps(error_response), flush=True)


def main() -> None:
    """Entry point for the HTTP bridge."""
    parser = argparse.ArgumentParser(
        description="HTTP bridge for MCP STDIO to HTTP translation",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s http://localhost:9000/mcp
  %(prog)s http://127.0.0.1:9000/mcp

Setup for ALCF systems:
  1. SSH to Aurora with tunnel:
     ssh -L 9000:localhost:9000 username@aurora.alcf.anl.gov

  2. On Aurora, start the MCP server:
     python -m borealis_mcp.server --transport http --port 9000

  3. Configure your MCP client to use this bridge
""",
    )
    parser.add_argument(
        "server_url",
        help="URL of the HTTP MCP server (e.g., http://localhost:9000/mcp)",
    )
    args = parser.parse_args()

    bridge = HTTPBridge(args.server_url)
    bridge.run()


if __name__ == "__main__":
    main()
